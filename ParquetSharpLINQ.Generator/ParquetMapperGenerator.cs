using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using ParquetSharpLINQ.Constants;

namespace ParquetSharpLINQ.Generator;

[Generator]
public class ParquetMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(source!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // Look for any class declaration with properties (we'll check attributes in semantic phase)
        return node is ClassDeclarationSyntax { Members.Count: > 0 };
    }

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol == null)
            return null;

        var hasParquetColumnProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Any(p => p.GetAttributes()
                .Any(a => a.AttributeClass?.ToDisplayString() == "ParquetSharpLINQ.Attributes.ParquetColumnAttribute"));

        return hasParquetColumnProperties ? classSymbol : null;
    }

    private static void Execute(INamedTypeSymbol classSymbol, SourceProductionContext context)
    {
        var source = GenerateMapper(classSymbol);
        context.AddSource($"{classSymbol.Name}_ParquetMapper.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateMapper(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var properties = GetParquetProperties(classSymbol);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using ParquetSharpLINQ;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    internal sealed class {className}ParquetMapper : IParquetMapper<{className}>");
        sb.AppendLine("    {");
        GenerateRequiredColumns(sb, properties);
        GenerateMapMethod(sb, className, properties);
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static List<PropertyInfo> GetParquetProperties(INamedTypeSymbol classSymbol)
    {
        var properties = new List<PropertyInfo>();
        var parquetColumnAttribute = "ParquetSharpLINQ.Attributes.ParquetColumnAttribute";
        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            if (property.SetMethod == null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
                continue;

            var attribute = property.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == parquetColumnAttribute);
            if (attribute == null)
                continue;
            var columnName = GetAttributeValue<string>(attribute, "Name") ?? property.Name;
            var isPartition = GetAttributeValue<bool>(attribute, "IsPartition");
            var throwOnMissing = GetAttributeValue<bool>(attribute, "ThrowOnMissingOrNull");
            properties.Add(new PropertyInfo
            {
                PropertyName = property.Name,
                ColumnName = columnName,
                TypeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                IsPartition = isPartition,
                ThrowOnMissingOrNull = throwOnMissing,
                IsNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated ||
                             (property.Type is INamedTypeSymbol namedType &&
                              namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
            });
        }

        return properties;
    }

    private static T? GetAttributeValue<T>(AttributeData attribute, string propertyName)
    {
        var namedArg = attribute.NamedArguments.FirstOrDefault(a => a.Key == propertyName);
        if (namedArg.Value.Value is T value)
            return value;
        if (attribute.ConstructorArguments.Length > 0 && propertyName == "Name")
            if (attribute.ConstructorArguments[0].Value is T ctorValue)
                return ctorValue;
        return default;
    }

    private static void GenerateRequiredColumns(StringBuilder sb, List<PropertyInfo> properties)
    {
        sb.AppendLine("        private static readonly string[] _requiredColumns = new[]");
        sb.AppendLine("        {");
        var requiredColumns = properties.Where(p => !p.IsPartition).Select(p => p.ColumnName).ToList();
        for (var i = 0; i < requiredColumns.Count; i++)
        {
            var comma = i < requiredColumns.Count - 1 ? "," : "";
            sb.AppendLine($"            \"{requiredColumns[i]}\"{comma}");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        public IReadOnlyList<string>? RequiredColumns => _requiredColumns;");
        sb.AppendLine();
    }

    private static void GenerateMapMethod(StringBuilder sb, string className, List<PropertyInfo> properties)
    {
        sb.AppendLine($"        public {className} Map(IReadOnlyDictionary<string, object?> row)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var instance = new {className}();");
        sb.AppendLine();
        foreach (var prop in properties)
        {
            const string partitionPrefix = PartitionConstants.PartitionPrefix;
            var key = prop.IsPartition ? $"{partitionPrefix}{prop.ColumnName}" : prop.ColumnName;
            sb.AppendLine($"            // {prop.PropertyName}");
            sb.AppendLine("            {");
            sb.AppendLine($"                if (TryGetValue(row, \"{key}\", out var rawValue))");
            sb.AppendLine("                {");
            if (prop.ThrowOnMissingOrNull)
            {
                sb.AppendLine("                    if (rawValue == null)");
                sb.AppendLine(
                    $"                        throw new InvalidOperationException(\"Required column '{prop.ColumnName}' is null.\");");
            }

            sb.AppendLine(
                $"                    instance.{prop.PropertyName} = ConvertValue<{prop.TypeName}>(rawValue);");
            sb.AppendLine("                }");
            if (prop.ThrowOnMissingOrNull)
            {
                sb.AppendLine("                else");
                sb.AppendLine("                {");
                sb.AppendLine(
                    $"                    throw new InvalidOperationException(\"Missing required column '{prop.ColumnName}'.\");");
                sb.AppendLine("                }");
            }

            sb.AppendLine("            }");
            sb.AppendLine();
        }

        sb.AppendLine("            return instance;");
        sb.AppendLine("        }");
        sb.AppendLine();
        GenerateHelperMethods(sb);
    }

    private static void GenerateHelperMethods(StringBuilder sb)
    {
        sb.AppendLine(
            "        private static bool TryGetValue(IReadOnlyDictionary<string, object?> row, string key, out object? value)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (row.TryGetValue(key, out value))");
        sb.AppendLine("                return true;");
        sb.AppendLine();
        sb.AppendLine("            foreach (var pair in row)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (string.Equals(pair.Key, key, StringComparison.OrdinalIgnoreCase))");
        sb.AppendLine("                {");
        sb.AppendLine("                    value = pair.Value;");
        sb.AppendLine("                    return true;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            value = null;");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private static T ConvertValue<T>(object? value)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (value == null)");
        sb.AppendLine("                return default(T)!;");
        sb.AppendLine();
        sb.AppendLine("            if (value is T typed)");
        sb.AppendLine("                return typed;");
        sb.AppendLine();
        sb.AppendLine("            var targetType = typeof(T);");
        sb.AppendLine("            var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;");
        sb.AppendLine();
        sb.AppendLine("            if (underlyingType.IsEnum)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (value is string enumText)");
        sb.AppendLine("                    return (T)Enum.Parse(underlyingType, enumText, true);");
        sb.AppendLine("                return (T)Enum.ToObject(underlyingType, value);");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            // Handle ParquetSharp.Date conversions");
        sb.AppendLine("            if (value is global::ParquetSharp.Date parquetDate)");
        sb.AppendLine("            {");
        sb.AppendLine("                var dateTime = parquetDate.DateTime;");
        sb.AppendLine();
        sb.AppendLine("                if (underlyingType == typeof(DateTime))");
        sb.AppendLine("                    return (T)(object)dateTime;");
        sb.AppendLine();
        sb.AppendLine("#if NET6_0_OR_GREATER");
        sb.AppendLine("                if (underlyingType == typeof(DateOnly))");
        sb.AppendLine("                    return (T)(object)DateOnly.FromDateTime(dateTime);");
        sb.AppendLine("#endif");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("#if NET6_0_OR_GREATER");
        sb.AppendLine("            if (underlyingType == typeof(DateOnly) && value is string dateOnlyStr)");
        sb.AppendLine(
            "                return (T)(object)DateOnly.Parse(dateOnlyStr, System.Globalization.CultureInfo.InvariantCulture);");
        sb.AppendLine();
        sb.AppendLine("            if (underlyingType == typeof(TimeOnly) && value is string timeOnlyStr)");
        sb.AppendLine(
            "                return (T)(object)TimeOnly.Parse(timeOnlyStr, System.Globalization.CultureInfo.InvariantCulture);");
        sb.AppendLine("#endif");
        sb.AppendLine();
        sb.AppendLine(
            "            return (T)Convert.ChangeType(value, underlyingType, System.Globalization.CultureInfo.InvariantCulture);");
        sb.AppendLine("        }");
    }

    private class PropertyInfo
    {
        public string PropertyName { get; set; } = null!;
        public string ColumnName { get; set; } = null!;
        public string TypeName { get; set; } = null!;
        public bool IsPartition { get; set; }
        public bool ThrowOnMissingOrNull { get; set; }
        public bool IsNullable { get; set; }
    }
}