using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using ParquetSharpLINQ.Constants;

namespace ParquetSharpLINQ.Generator;

[Generator]
public class ParquetMapperGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat FullyQualifiedNullableFormat =
        SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
            SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var collectedClasses = classDeclarations.Collect();

        context.RegisterSourceOutput(collectedClasses, static (spc, source) => ExecuteAll(source, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // Look for any class declaration with properties (we'll check attributes in semantic phase)
        return node is ClassDeclarationSyntax { Members.Count: > 0 };
    }

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol == null)
            return null;

        var hasParquetColumnProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Any(p => p.GetAttributes()
                .Any(a => a.AttributeClass?.ToDisplayString() == "ParquetSharpLINQ.Attributes.ParquetColumnAttribute"));

        return hasParquetColumnProperties ? classSymbol : null;
    }

    private static void ExecuteAll(ImmutableArray<INamedTypeSymbol?> classSymbols, SourceProductionContext context)
    {
        var symbols = classSymbols.Where(s => s != null).Cast<INamedTypeSymbol>();
        var uniqueSymbols = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var symbol in symbols)
        {
            if (!uniqueSymbols.Add(symbol))
                continue;

            var source = GenerateMapper(symbol);
            context.AddSource($"{symbol.Name}_ParquetMapper.g.cs", SourceText.From(source, Encoding.UTF8));

            var metadataSource = GenerateMetadata(symbol);
            context.AddSource($"{symbol.Name}_ParquetMetadata.g.cs", SourceText.From(metadataSource, Encoding.UTF8));
        }

        var registrySource = GenerateRegistry(uniqueSymbols.ToList());
        context.AddSource("ParquetGeneratedRegistry.g.cs", SourceText.From(registrySource, Encoding.UTF8));
    }

    private static string GenerateMapper(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var properties = GetParquetProperties(classSymbol);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using ParquetSharpLINQ;");
        sb.AppendLine("using ParquetSharpLINQ.Interfaces;");
        sb.AppendLine("using ParquetSharpLINQ.Mappers;");
        sb.AppendLine("using ParquetSharpLINQ.ParquetSharp;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    internal sealed class {className}ParquetMapper : IParquetMapper<{className}>");
        sb.AppendLine("    {");
        GenerateRequiredColumns(sb, properties);
        GenerateMapMethod(sb, className, properties);
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateMetadata(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var properties = GetParquetProperties(classSymbol);
        var indexedProperties = properties.Where(p => p.IsIndexed).ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.Immutable;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using ParquetSharpLINQ.Enumeration.Indexing;");
        sb.AppendLine("using ParquetSharpLINQ.Interfaces;");
        sb.AppendLine("using ParquetSharpLINQ.Mappers;");
        sb.AppendLine("using ParquetSharpLINQ.ParquetSharp;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    internal sealed class {className}ParquetMetadata : IParquetTypeMetadata");
        sb.AppendLine("    {");
        sb.AppendLine($"        public static readonly {className}ParquetMetadata Instance = new();");
        sb.AppendLine();
        GeneratePropertyToColumnMap(sb, properties);
        GeneratePartitionProperties(sb, properties);
        GeneratePropertyAccessors(sb, properties);
        GenerateIndexedDefinitions(sb, indexedProperties);
        sb.AppendLine();
        sb.AppendLine("        public IImmutableDictionary<string, string> PropertyToColumnMap => _propertyToColumnMap;");
        sb.AppendLine("        public IImmutableSet<string> PartitionPropertyNames => _partitionPropertyNames;");
        sb.AppendLine("        public IImmutableDictionary<string, IIndexedColumnDefinition> IndexedColumnDefinitions => _indexedColumnDefinitions;");
        sb.AppendLine("        public IReadOnlyDictionary<string, Delegate> PropertyAccessors => _propertyAccessors;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateRegistry(IReadOnlyList<INamedTypeSymbol> classSymbols)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using ParquetSharpLINQ.Interfaces;");
        sb.AppendLine("using ParquetSharpLINQ.Mappers;");
        sb.AppendLine();
        sb.AppendLine("namespace ParquetSharpLINQ.Mappers");
        sb.AppendLine("{");
        sb.AppendLine("    internal static class ParquetGeneratedRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        [ModuleInitializer]");
        sb.AppendLine("        internal static void Register()");
        sb.AppendLine("        {");
        foreach (var symbol in classSymbols)
        {
            var typeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var mapperName = Qualify(symbol.ContainingNamespace.ToDisplayString(), $"{symbol.Name}ParquetMapper");
            var metadataName = Qualify(symbol.ContainingNamespace.ToDisplayString(), $"{symbol.Name}ParquetMetadata");
            sb.AppendLine(
                $"            ParquetMapperRegistry.Register(typeof({typeName}), () => new {mapperName}(), {metadataName}.Instance);");
        }
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static List<PropertyInfo> GetParquetProperties(INamedTypeSymbol classSymbol)
    {
        var properties = new List<PropertyInfo>();
        var parquetColumnAttribute = "ParquetSharpLINQ.Attributes.ParquetColumnAttribute";
        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            if (property.SetMethod == null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
                continue;

            var attribute = property.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == parquetColumnAttribute);
            if (attribute == null)
                continue;
            var columnName = GetAttributeValue<string>(attribute, "Name") ?? property.Name;
            var isPartition = GetAttributeValue<bool>(attribute, "IsPartition");
            var allowMissingRaw = GetAttributeValue<bool>(attribute, "AllowMissing");
            var isIndexed = GetAttributeValue<bool>(attribute, "Indexed");
            var comparerType = GetAttributeValue<ITypeSymbol>(attribute, "ComparerType");
            var typeName = property.Type.ToDisplayString(FullyQualifiedNullableFormat);
            var isNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated ||
                             (property.Type is INamedTypeSymbol namedType &&
                              namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T);
            var isValueType = property.Type.IsValueType;
            var allowMissing = allowMissingRaw && isNullable;
            var underlyingType = property.Type is INamedTypeSymbol nullableType &&
                                 nullableType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T
                ? nullableType.TypeArguments[0]
                : property.Type;
            var underlyingTypeName = NormalizeTypeName(
                underlyingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            var typeOfName = isNullable && !isValueType && typeName.EndsWith("?", StringComparison.Ordinal)
                ? typeName.Substring(0, typeName.Length - 1)
                : typeName;

            properties.Add(new PropertyInfo
            {
                PropertyName = property.Name,
                ColumnName = columnName,
                TypeName = typeName,
                TypeOfName = typeOfName,
                UnderlyingTypeName = underlyingTypeName,
                IsPartition = isPartition,
                AllowMissing = allowMissing,
                IsNullable = isNullable,
                IsValueType = isValueType,
                IsIndexed = isIndexed,
                ComparerTypeName = comparerType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ComparerImplementsGeneric = comparerType?.AllInterfaces.Any(i =>
                    i.IsGenericType &&
                    i.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.Generic.IComparer<T>") == true,
                ComparerImplementsNonGeneric = comparerType?.AllInterfaces.Any(i =>
                    i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.IComparer") == true
            });
        }

        return properties;
    }

    private static T? GetAttributeValue<T>(AttributeData attribute, string propertyName)
    {
        var namedArg = attribute.NamedArguments.FirstOrDefault(a => a.Key == propertyName);
        if (namedArg.Value.Value is T value)
            return value;
        if (attribute.ConstructorArguments.Length > 0 && propertyName == "Name")
            if (attribute.ConstructorArguments[0].Value is T ctorValue)
                return ctorValue;
        return default;
    }

    private static void GenerateRequiredColumns(StringBuilder sb, List<PropertyInfo> properties)
    {
        sb.AppendLine("        private static readonly string[] _requiredColumns = new[]");
        sb.AppendLine("        {");
        var requiredColumns = properties
            .Where(p => !p.IsPartition && !p.AllowMissing)
            .Select(p => p.ColumnName)
            .ToList();
        for (var i = 0; i < requiredColumns.Count; i++)
        {
            var comma = i < requiredColumns.Count - 1 ? "," : "";
            sb.AppendLine($"            \"{requiredColumns[i]}\"{comma}");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        public IReadOnlyList<string>? RequiredColumns => _requiredColumns;");
        sb.AppendLine();
    }

    private static void GenerateMapMethod(StringBuilder sb, string className, List<PropertyInfo> properties)
    {
        sb.AppendLine($"        public {className} Map(ParquetSharpLINQ.ParquetSharp.ParquetRow.ParquetRow row)");
        sb.AppendLine("        {");
        sb.AppendLine("            return Map(row, null);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        public {className} Map(ParquetSharpLINQ.ParquetSharp.ParquetRow.ParquetRow row, IReadOnlyCollection<string>? requestedColumns)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var instance = new {className}();");
        sb.AppendLine();
        sb.AppendLine("            HashSet<string>? requestedColumnsSet = null;");
        sb.AppendLine("            if (requestedColumns != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                requestedColumnsSet = new HashSet<string>(requestedColumns, StringComparer.OrdinalIgnoreCase);");
        sb.AppendLine("            }");
        sb.AppendLine();
        foreach (var prop in properties)
        {
            const string partitionPrefix = PartitionConstants.PartitionPrefix;
            var key = prop.IsPartition ? $"{partitionPrefix}{prop.ColumnName}" : prop.ColumnName;
            var disallowNullValue = !prop.IsNullable && !prop.IsValueType;
            var requireNonNull = !prop.AllowMissing;
            sb.AppendLine($"            // {prop.PropertyName}");
            sb.AppendLine(
                $"            if (requestedColumnsSet?.Contains(\"{prop.PropertyName}\") != false)");
            sb.AppendLine("            {");
            sb.AppendLine(
                $"                if (ParquetMapperHelpers.TryGetValue<{prop.TypeName}>(row, \"{key}\", out var typedValue))");
            sb.AppendLine("                {");
            if (disallowNullValue)
            {
                sb.AppendLine("                    if (typedValue == null)");
                sb.AppendLine(
                    $"                        throw new InvalidOperationException(\"Required column '{prop.ColumnName}' is null.\");");
            }
            sb.AppendLine($"                    instance.{prop.PropertyName} = typedValue;");
            sb.AppendLine("                }");
            if (requireNonNull)
            {
                sb.AppendLine("                else");
                sb.AppendLine("                {");
                sb.AppendLine(
                    $"                    throw new InvalidOperationException(\"Missing required column '{prop.ColumnName}'.\");");
                sb.AppendLine("                }");
            }
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        sb.AppendLine("            return instance;");
        sb.AppendLine("        }");
    }

    private class PropertyInfo
    {
        public string PropertyName { get; set; } = string.Empty;
        public string ColumnName { get; set; } = string.Empty;
        public string TypeName { get; set; } = string.Empty;
        public string TypeOfName { get; set; } = string.Empty;
        public string UnderlyingTypeName { get; set; } = string.Empty;
        public bool IsPartition { get; set; }
        public bool AllowMissing { get; set; }
        public bool IsNullable { get; set; }
        public bool IsValueType { get; set; }
        public bool IsIndexed { get; set; }
        public string? ComparerTypeName { get; set; }
        public bool ComparerImplementsGeneric { get; set; }
        public bool ComparerImplementsNonGeneric { get; set; }
    }

    private static string Qualify(string? namespaceName, string typeName)
    {
        if (string.IsNullOrWhiteSpace(namespaceName))
            return typeName;

        return $"{namespaceName}.{typeName}";
    }

    private static string NormalizeTypeName(string typeName)
    {
        return typeName switch
        {
            "bool" => "global::System.Boolean",
            "byte" => "global::System.Byte",
            "short" => "global::System.Int16",
            "int" => "global::System.Int32",
            "long" => "global::System.Int64",
            "float" => "global::System.Single",
            "double" => "global::System.Double",
            "decimal" => "global::System.Decimal",
            "string" => "global::System.String",
            "DateTime" => "global::System.DateTime",
            "DateOnly" => "global::System.DateOnly",
            "TimeOnly" => "global::System.TimeOnly",
            "Guid" => "global::System.Guid",
            _ => typeName
        };
    }

    private static void GeneratePropertyToColumnMap(StringBuilder sb, List<PropertyInfo> properties)
    {
        sb.AppendLine("        private static readonly IImmutableDictionary<string, string> _propertyToColumnMap =");
        sb.AppendLine("            ImmutableDictionary.CreateRange(StringComparer.OrdinalIgnoreCase, new KeyValuePair<string, string>[]");
        sb.AppendLine("            {");
        foreach (var prop in properties)
        {
            sb.AppendLine($"                new(\"{prop.PropertyName}\", \"{prop.ColumnName}\"),");
        }
        sb.AppendLine("            });");
        sb.AppendLine();
    }

    private static void GeneratePartitionProperties(StringBuilder sb, List<PropertyInfo> properties)
    {
        sb.AppendLine("        private static readonly IImmutableSet<string> _partitionPropertyNames =");
        sb.AppendLine("            ImmutableHashSet.CreateRange<string>(StringComparer.OrdinalIgnoreCase, new string[]");
        sb.AppendLine("            {");
        foreach (var prop in properties.Where(p => p.IsPartition))
        {
            sb.AppendLine($"                \"{prop.PropertyName}\",");
        }
        sb.AppendLine("            });");
        sb.AppendLine();
    }

    private static void GeneratePropertyAccessors(StringBuilder sb, List<PropertyInfo> properties)
    {
        sb.AppendLine("        private static readonly IReadOnlyDictionary<string, Delegate> _propertyAccessors =");
        sb.AppendLine("            new Dictionary<string, Delegate>(StringComparer.OrdinalIgnoreCase)");
        sb.AppendLine("            {");
        foreach (var prop in properties)
        {
            var key = prop.IsPartition
                ? $"{PartitionConstants.PartitionPrefix}{prop.ColumnName}"
                : prop.ColumnName;
            var disallowNullValue = !prop.IsNullable && !prop.IsValueType;
            var requireNonNull = !prop.AllowMissing;
            var canReturnDefault = !requireNonNull && (prop.IsNullable || prop.IsValueType);
            sb.AppendLine($"                [\"{prop.PropertyName}\"] = new Func<ParquetSharpLINQ.ParquetSharp.ParquetRow.ParquetRow, {prop.TypeName}>(row =>");
            sb.AppendLine("                {");
            sb.AppendLine(
                $"                    if (ParquetMapperHelpers.TryGetValue<{prop.TypeName}>(row, \"{key}\", out var value))");
            sb.AppendLine("                    {");
            if (disallowNullValue)
            {
                sb.AppendLine("                        if (value == null)");
                sb.AppendLine(
                    $"                            throw new InvalidOperationException(\"Required column '{prop.ColumnName}' is null.\");");
            }
            sb.AppendLine("                        return value;");
            sb.AppendLine("                    }");
            if (requireNonNull)
            {
                sb.AppendLine(
                    $"                    throw new InvalidOperationException(\"Missing required column '{prop.ColumnName}'.\");");
            }
            else
            {
                if (canReturnDefault)
                {
                    sb.AppendLine($"                    return default({prop.TypeName});");
                }
                else
                {
                    sb.AppendLine(
                        $"                    throw new InvalidOperationException(\"Missing required column '{prop.ColumnName}'.\");");
                }
            }
            sb.AppendLine("                }),");
        }
        sb.AppendLine("            };");
        sb.AppendLine();
    }

    private static void GenerateIndexedDefinitions(StringBuilder sb, List<PropertyInfo> indexedProperties)
    {
        sb.AppendLine("        private static readonly IImmutableDictionary<string, IIndexedColumnDefinition> _indexedColumnDefinitions =");
        sb.AppendLine("            ImmutableDictionary.CreateRange(StringComparer.OrdinalIgnoreCase, new KeyValuePair<string, IIndexedColumnDefinition>[]");
        sb.AppendLine("            {");
        foreach (var prop in indexedProperties)
        {
            sb.AppendLine($"                new(\"{prop.PropertyName}\", new {prop.PropertyName}IndexedDefinition()),");
        }
        sb.AppendLine("            });");
        sb.AppendLine();

        foreach (var prop in indexedProperties)
        {
            GenerateIndexedDefinitionClass(sb, prop);
            sb.AppendLine();
        }
    }

    private static void GenerateIndexedDefinitionClass(StringBuilder sb, PropertyInfo prop)
    {
        sb.AppendLine($"        private sealed class {prop.PropertyName}IndexedDefinition : IIndexedColumnDefinition");
        sb.AppendLine("        {");
        sb.AppendLine($"            public string ColumnName => \"{prop.ColumnName}\";");
        sb.AppendLine($"            public string PropertyName => \"{prop.PropertyName}\";");
        sb.AppendLine($"            public Type PropertyType => typeof({prop.TypeOfName});");
        sb.AppendLine($"            public bool IsNullable => {(prop.IsNullable ? "true" : "false")};");
        sb.AppendLine();
        sb.AppendLine($"            private static readonly IComparer<{prop.TypeName}> _comparer = {BuildComparerFactoryExpression(prop)};");
        sb.AppendLine();
        sb.AppendLine("            public RowGroupIndex BuildRowGroupIndex(IParquetReader reader, string filePath)");
        sb.AppendLine("            {");
        sb.AppendLine($"                var rowGroupValues = reader.ReadColumnValuesByRowGroup<{prop.TypeName}>(filePath, ColumnName);");
        sb.AppendLine("                var rowGroups = new Dictionary<int, RowGroupValues>();");
        sb.AppendLine("                for (var rowGroupIndex = 0; rowGroupIndex < rowGroupValues.Count; rowGroupIndex++)");
        sb.AppendLine("                {");
        if (!prop.IsNullable && !prop.IsValueType)
        {
            sb.AppendLine("                    var values = rowGroupValues[rowGroupIndex];");
            sb.AppendLine("                    for (var i = 0; i < values.Length; i++)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        if (values[i] is null)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            throw new InvalidOperationException(");
            sb.AppendLine($"                                $\"Indexed column '{prop.ColumnName}' is null for non-nullable property '{prop.PropertyName}'.\");");
            sb.AppendLine("                        }");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    rowGroups[rowGroupIndex] = new RowGroupValues<" + prop.TypeName + ">(new SortedValueArray<" + prop.TypeName + ">(values, _comparer));");
        }
        else
        {
            sb.AppendLine("                    var values = rowGroupValues[rowGroupIndex];");
            sb.AppendLine("                    rowGroups[rowGroupIndex] = new RowGroupValues<" + prop.TypeName + ">(new SortedValueArray<" + prop.TypeName + ">(values, _comparer));");
        }
        sb.AppendLine("                }");
        sb.AppendLine("                return new RowGroupIndex(rowGroups);");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            public IIndexedPredicateConstraint? BuildBinaryConstraint(ExpressionType nodeType, Expression valueExpression)");
        sb.AppendLine("            {");
        sb.AppendLine($"                if (!TryEvaluateValue(valueExpression, out {prop.TypeName} convertedValue))");
        sb.AppendLine("                    return null;");
        sb.AppendLine();
        if (!prop.IsNullable && !prop.IsValueType)
        {
            sb.AppendLine("                if (convertedValue == null)");
            sb.AppendLine("                    return null;");
        }
        sb.AppendLine("                return nodeType switch");
        sb.AppendLine("                {");
        sb.AppendLine($"                    ExpressionType.Equal => new EqualsConstraint<{prop.TypeName}>(this, convertedValue),");
        sb.AppendLine($"                    ExpressionType.NotEqual => new NotEqualsConstraint<{prop.TypeName}>(this, convertedValue),");
        sb.AppendLine($"                    ExpressionType.GreaterThan => new ComparisonConstraint<{prop.TypeName}>(this, convertedValue, ComparisonKind.GreaterThan),");
        sb.AppendLine($"                    ExpressionType.GreaterThanOrEqual => new ComparisonConstraint<{prop.TypeName}>(this, convertedValue, ComparisonKind.GreaterThanOrEqual),");
        sb.AppendLine($"                    ExpressionType.LessThan => new ComparisonConstraint<{prop.TypeName}>(this, convertedValue, ComparisonKind.LessThan),");
        sb.AppendLine($"                    ExpressionType.LessThanOrEqual => new ComparisonConstraint<{prop.TypeName}>(this, convertedValue, ComparisonKind.LessThanOrEqual),");
        sb.AppendLine("                    _ => null");
        sb.AppendLine("                };");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine($"            private static bool TryEvaluateValue(Expression expression, out {prop.TypeName} value)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (expression is ConstantExpression { Value: null })");
        sb.AppendLine("                {");
        if (prop.IsNullable)
        {
            sb.AppendLine("                    value = default;");
            sb.AppendLine("                    return true;");
        }
        else
        {
            sb.AppendLine("                    Unsafe.SkipInit(out value);");
            sb.AppendLine("                    return false;");
        }
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine($"                    var converted = Expression.Convert(expression, typeof({prop.TypeOfName}));");
        sb.AppendLine($"                    var lambda = Expression.Lambda<Func<{prop.TypeOfName}>>(converted);");
        sb.AppendLine("                    var evaluated = lambda.Compile().Invoke();");
        sb.AppendLine("                    value = evaluated;");
        sb.AppendLine("                    return true;");
        sb.AppendLine("                }");
        sb.AppendLine("                catch");
        sb.AppendLine("                {");
        sb.AppendLine("                    Unsafe.SkipInit(out value);");
        sb.AppendLine("                    return false;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine($"            public IIndexedPredicateConstraint CreateAlwaysMatchConstraint() => new AlwaysMatchConstraint<{prop.TypeName}>(this);");
        sb.AppendLine("        }");
    }

    private static string BuildComparerFactoryExpression(PropertyInfo prop)
    {
        if (prop.ComparerTypeName == null)
            return $"ComparerFactory.CreateDefault<{prop.TypeName}>()";

        if (prop.ComparerImplementsGeneric)
            return $"ComparerFactory.CreateGeneric(new {prop.ComparerTypeName}())";

        if (prop.ComparerImplementsNonGeneric)
            return $"ComparerFactory.CreateNonGeneric<{prop.TypeName}>(new {prop.ComparerTypeName}())";

        return $"ComparerFactory.CreateDefault<{prop.TypeName}>()";
    }
}
